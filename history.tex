\section{if-conversion的发展简史}

if-conversion最早由Rice大学的Allen等人在1983年提出\cite{allen1983Concondeptodatdep}。当时已有向量机的出现，并且新一代的Fortran也一定会提供向量操作来支持向量机。不幸的是，由于之前版本的Fortran中不支持向量操作，所以相当大的一部分旧有的Fortran程序无法充分利用处理器的新特性，这就意味着，自动向量化的研究势在必行。当时Rice大学的人正在开发一个翻译程序，称为并行Fortran转换器（Parallel Fortran Converter，简称PFC），它能将Fortran 66或者Fortran 77代码翻译成新一代Fortran的代码，并且通过自动向量化来充分利用向量操作。当时的编译器进行程序变换还是基于数据依赖，分支语句产生的控制依赖不能非常好的融入到当时的体系中去。与此同时，分支语句的存在也会使得自动向量化无法进行。由于这两个原因，Allen就提出了将程序中的所有分支语句移除而转换成谓词执行的一些算法。Allen的算法的目的比较看重向量化，这算法是直接在源代码上进行操作的，它可以将所有的前向分支跟出口分支消除。但是Allen的算法没有考虑到如何最小化谓词的分配等的问题。尽管Allen的算法可以将分支转换为谓词执行，但是编译器要想判断是否可以进行向量化，必须先对代码进行if-conversion，这样就将所有的控制依赖转化为数据依赖，然后才能使用基于数据依赖的算法判断是否能够进行向量化，一旦无法向量化，不单单是if-conversion执行的时间被浪费掉，而且分支的消除反而会对代码的执行效率产生影响，糟糕的是，if-conversion已经将代码变得面目全非无法还原。

1987年，Ferrante等人提出了程序依赖图（PDG）的概念\cite{ferrante1987prodepgraitsuseopt}。这是一个非常重要的工作，因为PDG是一个新的框架，在这个框架下，数据依赖跟控制依赖被统一地进行处理，一切旧有的算法都可以高效地纳入新的框架下。由于不再存在之前的编译器无法处理控制依赖的问题，也就没有必要再利用if-conversion将控制依赖转化为数据依赖了。同时这个框架对if-conversion的发展也起到了承上启下的作用，后来对if-conversion的研究都是在这个框架下的。

虽然不再需要用if-conversion将控制依赖转化为数据依赖，但是if-conversion并没还有因此失去它的意义。正如上一节所说，程序中的分支语句已经称为高性能体系结构中性能提升的主要障碍，而if-conversion恰好可以用谓词执行来代替分支，进而提高效率。只不过问题的核心已经不是像Allen所说的那样，将控制依赖转化为数据依赖，也不是向量化，而是减少由于分支语句的存在对程序性能造成的影响，这也对经过if-conversion转换之后的代码的性能提出了要求。

1991年，Park跟Schlansker提出了RK算法\cite{JosephC.H.Park1991}，这个算法用于消除所有最内层循环的循环体中的分支语句，这个算法可以最小化谓词的数量，以及定义谓词的操作的数量。但问题是，谓词以及定义谓词的操作的数量最小并不意味着算法最优，之前也分析过（见\fref{sec:ifcvt_harm_performance}），分支消除也会对性能造成一定的负面影响，所以，到底是否进行分支消除，如果是，应该对哪部分分支进行消除也是需要研究的问题。

1992年，Mahlke等人提出了Hyperblock的概念\cite{ScottA.Mahlke1992a}。Hyperblock是一个单入口多出口的谓词化的基本块的集合。这篇文章为选择性地if-conversion提供了一个框架，它告诉人们如何只对部分基本块进行if-conversion而保持一些其他的基本块不变：将基本块按照性质不同划分到不同的Hyperblock中去，然后对每个Hyperblock进行if-conversion以消除其中的分支。通过将基本块有选择地包括在Hyperblock之内或者排除在Hyperblock之外，就可以实现性能的最大化。这篇文章还提供了Hyperblock形成以后的一些优化算法。但是，这篇文章对Hyperblock选择的讨论比较少，并没有告诉人们如何划分Hyperblock才是最优的，自然，这也成为之后学者研究的内容。

至此，Hyperblock概念已经提供了选择性地进行if-conversion的机制，并且RK算法已经告诉我们如何在选定Hyperblock以后产生最优代码。可以说，关于if-conversion的研究，剩下的只是策略的问题了。

1993年，Warter等人提出了逆向if-conversion (reverse if-conversion)的概念\cite{Warter1993}。在这算是一个小插曲，因为作者的工作重心并不是if-conversion本身，而只是提出可以利用if-conversion来进行全局指令调度：首先通过if-conversion将分支消除，然后进行局部调度，最后再用作者提出来的逆向if-conversion算法将代码还原。单看工作本身，对if-conversion并没有大的贡献，而只是一个小小的应用，本来是不足以写进if-conversion的发展史的，但是由于逆向if-conversion的提出对后面的研究有着很大的启发作用，因此这篇文章还是对if-conversion有着深远影响的。

1997年，August等人对if-conversion策略进行了详细地讨论\cite{August1997}。August详细讨论了处理器对谓词执行的支持给编译器带来的挑战，Hyperblock选择等等问题，并且提出了一个平衡控制流跟谓词执行的框架：首先在编译过程的早期大量应用if-conversion来发掘谓词执行带来的全部好处，此时形成的Hyperblock比目标体系能处理的大得多，然后在比较靠后的编译阶段进行部分逆向if-conversion，根据目标机器调整每个Hyperblock的谓词化代码的数量，以平衡控制流跟谓词数目。

有了机制，又有了策略，可以说，此时if-conversion的研究最重要的工作已经完成，if-conversion像是一个完成的大厦，剩下的就是修修补补了。从1983年Allen的开山之作，到1997年August为大厦添上最后一块砖，整个过程历时14年，5篇意义重大的文章。