\section{Allen及其同事的开山之作}

if转换最早由Rice大学的Allen等人于1983年提出\cite{allen1983Concondeptodatdep}，
在当时，还没有处理控制依赖的好的方法，于是Allen提出了if转换来消除所有的控制依赖，
程序进行if转换以后，所有的分支语句将会消失，程序中将会只有控制依赖。

\subsection{基本概念}

为了表述方便，Allen引入了一些基本概念：
\begin{itemize}
\item \textbf{动作语句(action statements)}
能导致计算状态改变或者产生重要的副作用的语句，比如：赋值、读、写、函数调用。
\item \textbf{分支语句(branch statements)}
显式的引起控制转移的语句，比如：goto语句。注意的时函数调用不是分支语句而是动作语句，因为在给定的模块中，函数调用可以堪称宏操作。
\item \textbf{迭代语句(iterative statements)}
造成其他语句循环执行的语句，例如：do语句。
\item \textbf{占位符语句(placeholder statements)}
没有任何动作，只是用来占位的语句，例如：Fortran中的continue语句。
\end{itemize}

if转换的目标是消除所有的分支语句，分支的消除会导致一些语句被替代为条件执行语句，这些条件执行语句的条件被称为\textbf{控制条件(guard)}:

\begin{itemize}
\item \textbf{定义}：条件动作语句的\textbf{控制条件(guard)}是一个布尔表达式，这个表达式表示这条语句执行的条件，当且仅当布尔表达式为真时，这条语句的动作才会执行。
\end{itemize}

本节中条件动作语句将用下列形式表示：
\begin{lstlisting}[language=FORTRAN]
IF(guard) statement
\end{lstlisting}

分支分为3种类型：
\begin{itemize}
\item \textbf{出口分支(exit branch)}
终止一个或者多个循环的分支，例如：
\begin{lstlisting}[language=FORTRAN]
	DO 100 I=1,100
		IF (ABS(A(I)-B(I)).LE. DEL) GOTO 200
100	CONTINUE
	...
200 CONTINUE
\end{lstlisting}
\item \textbf{前向分支(forward branch)}
分支的跳转目标在当前语句之后但在相同的循环中的语句，例如：
\begin{lstlisting}[language=FORTRAN]
	DO 100 I = 1, 10
		IF (A(I).EQ.0.0) GOTO 100
		B(I) = B(I)/A(I)
100	CONTINUE
\end{lstlisting}
\item \textbf{后向分支(backward branch)}
分支的跳转目标在当前语句之前但在相同的循环中的语句，例如：
\begin{lstlisting}[language=FORTRAN]
10	I = I + 1
	A(I) = A(I) + B(I)
	IF (I .LE. 100) GOTO 10
\end{lstlisting}
\end{itemize}

if转换使用如下两种变换来消除程序中的分支：

\begin{itemize}
\item \textbf{分支重定位(branch relocation)}：将分支语句一层层移出循环，直至分支语句与其目标在嵌套在相同的循环中。该过程把所有的出口分支转换为前向或者后向分支。
\item \textbf{分支移除(branch removal)}：将所有的前向分支移除，取而代之的是，计算每个指令的控制条件，并将动作语句用条件动作语句来代替。
\end{itemize}

\subsection{出口分支的处理}

为了执行分支重定位，引入\textbf{出口标记(exit flag)}的概念：
\begin{itemize}
\item \textbf{出口标记(exit flag)}是一个布尔变量，每一个出口分支都有与其对应的一个出口标记。
在程序执行的过程中，该变量在其对应分支被执行之前的值始终为真，而在对应分支被执行以后其值变为假。
在这里，出口分支i的出口标记记为$ex_i$，与其对应的FORTRAN变量名记为EXi
\end{itemize}

在只有一个循环、一个出口分支的情况下，例如：
\begin{lstlisting}[language=FORTRAN]
	DO 100 I = 1,100
		S1
		IF (X(I)) GOTO 200
		S2
100	CONTINUE
	S3
200 S4
\end{lstlisting}

程序中唯一的一个出口分支对应的出口标记为$ex_1$。
由出口标记的定义不难看出，在循环开始的时候，该变量的值应该为真，因为此时分支语句显然没有执行。
此后运行过程中，该变量的值一直保持为真，直到分支被成功执行，即X(I)为假时，该变量才为假。
由于出口分支被消除，而循环中的每个动作语句将会被替换为条件动作语句。
显然，语句的控制条件就是$ex_1$。

不难看出，重定位之后的代码应该为：
\begin{lstlisting}[language=FORTRAN]
	EX1 = .TRUE.
	DO 100 I = 1,100
		IF (EX1) S1
		IF (EX1) EX1 = .NOT. X(I)
		IF (EXI) S2
100	CONTINUE
	IF (.NOT. EX1) GOTO 200
	S3
200	S4
\end{lstlisting}

不难理解，在一个循环、n个出口分支的情况下，每个语句（包括所有新引入的对哥哥出口标记赋值的语句）的控制条件为：$ex_1\wedge{}ex_2\wedge\ldots{}\wedge{}ex_n$

这个方法也可以非常容易的拓展到多个循环、多个出口分支的情况：
\begin{lstlisting}[language=FORTRAN]
	DO 200 I = 1,100
50		S1
		DO 100 J=1,1OO
			S2
			IF X(I,J) GOTO 300
			S3
			IF Y(I,J) GOTO 50
			S4
100		CONTINUE
		S5
200	CONTINUE
300	S6
\end{lstlisting}
经过分支重定向以后变为：
\begin{lstlisting}[language=FORTRAN]
	EX1 = .TRUE.
	DO 200 I =1,100
50		IF (EX1) S1
		IF (EX1) EX2 = .TRUE.
		DO 100 J=1,1OO
			IF (EX1 .AND. EX2) S2
			IF (EX1 .AND. EX2) EX1 = .NOT. X(I,J)
			IF (EX1 .AND. EX2) S3
			IF (EX1 .AND. EX2) EX2 = .NOT. Y(I,J)
			IF (EX1 .AND. EX2) S4
100		CONTINUE
		IF (EX1 .AND. .NOT. EX2) GOTO 50
		IF (EX1) S5
200	CONTINUE
	IF (.NOT. EX1) GOTO 300
300	S6
\end{lstlisting}
该算法的伪代码如算法\ref{algo:RelocateBranch}所示:

\begin{algorithm}[H]
	\label{algo:RelocateBranch}
	\caption{relocate\_branches(x)}
	\KwIn{x是一个DO循环}
	\KwOut{不含出口分支的版本}
	\tcc{loop\_guard表示所有出口标记的合取}	
	$loop\_guard = true$\;
	\For{跳出循环x的每个出口分支IF(P) GOTO S1}{
		创建一个新的出口标记$ex_i$，其对应的FORTRAN变量为EXi\;
		在x前插入语句"EXi = .TRUE."\;
		$loop\_guard = loop\_guard \wedge ex_i$\;
		在循环后插入分支语句“IF (.NOT. EXi) GOTO S1”\;
		将出口分支替换为赋值语句“EXi = .NOT. P”\;
	}
	\For{循环x中的每个DO循环y}{
		relocate\_branches(y)\;
	}
	\For{循环x中的每个非循环语句y}{
		$guard(y) = guard(y) \wedge loop\_guard$\;
	}
\end{algorithm}

\subsection{前向分支的处理}

前向分支是最简单的分支，它的移除称为\textbf{前向分支移除(forward branch removal)}。为了进行前向分支移除，引入\textbf{当前条件(current condition)}概念：

\begin{itemize}
\item \textbf{当前条件(current condition)}是一个逻辑表达式，它表示现在正在处理的表达式被执行的条件。
\end{itemize}

前向分支在两个地方影响控制流：

\begin{itemize}
\item \textbf{分支处}：在没有其他控制流改变的情况下，前向分支之后紧跟的语句只有在分支没有发生的条件下才会被执行。
所以，如果分支处的当前条件为$cc_1$，分支的条件$p$，那么紧跟分支之后的语句的控制条件为$cc_1\wedge \neg p$
\item \textbf{目标处}：控制流到达分支目标处有两种情况，一种是分支语句没有执行，控制流直接顺序执行到达目标处，另一种则是通过分支语句直接到达目标处。
如果目标前面的那条语句的控制条件是$cc_2$，则目标处的控制条件应该为$cc_2\vee \left(cc_1\wedge p\right)$
\end{itemize}

引入\textbf{分支标记(branch flags)}的概念：
\begin{itemize}
\item 每个前向分支(编号为i)对应于一个称为\textbf{分支标记(branch flags)}的变量$br_i$，$br_i$为真当且仅当对应分支语句的分支条件为真。
\end{itemize}

例如代码：

\begin{lstlisting}[language=FORTRAN]
	DO 100 I = 1, 100
		IF (A(I).GT.10) GOTO 60
			A(I) = A(I) + 10
			IF (B(I).GT.1O) GOTO 80
				B(I) = B(l) + 10
60			A(I) = B(I) +A(I)
80	B(I) = A(I) - 5
100	CONTINUE 
\end{lstlisting}

为两个分支分别引入一个布尔变量$br_1$跟$br_2$，他们对应的FORTRAN变量分别为BR1和BR2。
为了计算BR1和BR2，我们分别在两个分支处插入代码:
\begin{lstlisting}[language=FORTRAN]
BR1 = A(I).GT.1O
\end{lstlisting}
以及
\begin{lstlisting}[language=FORTRAN]
BR2 = B(I).GT.1O
\end{lstlisting}

由之前的描述，不难发现示例中的各个动作语句的控制条件条件为：

\begin{tabular}{|c|c|}
\hline
行号	&	控制条件																					\\
\hline
3	&	$\neg br_1$																				\\
5	&	$\neg br_1 \wedge\neg br_2$																\\
6	&	$br_1\vee\left(\neg br_1 \wedge\neg br_2\right)$										\\
7	&	$br_1\vee\left(\neg br_1 \wedge br_2\right)\vee\left(\neg br_1 \wedge\neg br_2\right)$	\\
\hline
\end{tabular}

为了防止控制条件的不断增长，编译器必须具备布尔化简的能力，例如第七行对应的布尔表达式恒真。
我们$\mu\left(p\right)$表示逻辑表达式$p$经过布尔化简以后转换成逻辑表达式的FORTRAN语句表示。
经过前向分支消除以及布尔优化后的结果为：

\begin{lstlisting}[language=FORTRAN]
	DO 100 I = 1, 100
		BR1 = A(I).GT.10
		IF (.NOT. BR1) A(I) = A(I) + 10
		IF (.NOT. BR1) BR2 = B(I).GT.1O
		IF (.NOT. BR1 .AND. .NOT. BR2) B(I) = B(I) + 10
		IF (BRI .OR. .NOT. BR2) A(I) = B(I) +A(I)
		B(I) = A(I) + 5
100	CONTINUE
\end{lstlisting}
前向分支消除的伪代码算法\ref{algo:ForwardConvert}如下：

\begin{algorithm}[H]
	\label{algo:ForwardConvert}
	\caption{$forward\_convert\left(x,cc_0\right)$}
	\KwIn{x是要考虑的分支，$cc_0$是x前的控制条件}
	\KwOut{返回x的控制条件，输出不含前向分支的版本}
	\tcc{$predicate\_list\left(x\right)$是一个队列，队列包含所有的由于分支到x而必须在x处分离的分支条件}	
	$cc_1\leftarrow cc_0$\;
	\While{$not\_empty\left(predicate\_list\left(x\right)\right)$}{
		$p\leftarrow get\_from\_queue\left(predicate\_list\left(x\right)\right)$\;
		$cc_1\leftarrow cc_1\vee p$\;
	}
	\Switch{$statement\_type(x)$}{
		\Case{前向分支IF(P) GOTO y}{
			创建一个新的分支标记$br_i$，其对应的FORTRAN变量为BRi\;
			把x替换为“IF($\mu\left(cc_1\right))$ BRi = P”\;
			$add\_to\_queue\left(predicate\_list\left(y\right),cc_1\wedge br_i\right)$\;
			$cc_1\leftarrow cc_1\wedge\neg br_1$\;
		}
		\Case{前向分支GOTO y}{
			$add\_to\_queue\left(predicate\_list\left(y\right),cc_1\right)$\;
			$cc_1\leftarrow false$\;
			删除分支x\;
		}
		\Other{
			设置x的控制条件为x\;
		}
	}
	\Return{$cc_1$}
\end{algorithm}

\subsection{后向分支的处理}
后向分支会产生隐式循环，因此无法被if转换消除。然而更严重的是，后向分支导致从循环外跳转到循环内成为可能，这就导致算法\ref{algo:ForwardConvert}产生不正确的代码。
一种简单的做法是，保持隐式循环区内的所有代码不变，不对隐式循环区内的代码进行优化，然而这是一个非常严重的限制，我们必须考虑后向分支存在的情况下代码的优化。
本节介绍完全分支移除算法\ref{algo:CompleteBranchRemoval}，这个算法可以在后向分支存在的前提下删除所有的前向分支。

考虑下面这个例子：
\begin{lstlisting}[language=FORTRAN]
	IF(X) GOTO 200
	...
100	S1
	...
200	S2
	...
	IF(Y) GOTO 100
\end{lstlisting}

S1的控制条件必须反映下面事实:
\begin{enumerate}
\item 仅当X为假的时候，S1才会在在第一轮得到执行
\item 如果是从后向分支跳转过来的，那么S1将永远得到执行
\end{enumerate}
这暗示我们引入一个新的标记来表示S1的执行是否是由于后向分支跳转到此而执行的，这个标记称之为\textbf{向后分支标记(branch back flag)}，记为bb，其对应的FORTRAN变量为BB。

这样，例子中的程序就可以化为：
考虑下面这个例子：
\begin{lstlisting}[language=FORTRAN]
	BR1 = X
	IF(.NOT. BR1) ...
	BB1 = .FALSE.
100	IF(.NOT. BR1 .OR. BR1 .AND. BB1) S1
	IF(.NOT. BR1 .OR. BR1 .AND. BB1) ...
200	S2
	...
	IF(Y) THEN
		BB1 = .TRUE.
		GOTO 100
	ENDIF
\end{lstlisting}

可以看出，后向分支j的目标语句y被执行，可以分为两种情况：
\begin{enumerate}
\item \textbf{顺序执行}:
y前面的语句执行完成以后，顺序执行到y，此时y的控制条件就是y前面语句的控制条件$cc_y$。
\item \textbf{后向分支}:
控制流通过分支i进入隐式循环区，然后通过后向分支j跳转至此。这种情况发生的条件是$br_i\wedge bb_j$
\end{enumerate}
于是，y的控制条件应为$cc_y\vee\left(br_i\wedge bb_j\right)$。
如果有不止一个分支能够进入隐式循环区，则将式中的$br_i$换为所有这些进入隐式循环区的分支的分支标记的析取。

考虑另外一个例子：
\begin{lstlisting}[language=FORTRAN]
	IF(X) GOTO 200
100	S1
	GOTO 300
200	S2
	IF(Y) GOTO 100
300	S3
\end{lstlisting}
显然，正确的S2的控制条件应该是$br_1\wedge \neg bb_1$，要移除S2前面的分支语句，$\neg bb_1$必须被添加到相应语句的控制条件里面去。
考虑到这一点，转换后的代码应该为：
\begin{lstlisting}[language=FORTRAN]
	BR1 = X
	BB1 = .FALSE.
100	IF(.NOT. BR1 .OR. BR1 .AND. BB1) S1
	/*GOTO 300已经被移除*/
200	IF(.NOT. BB1 .AND. BR1) S2
	IF(.NOT. BB1 .AND. BR1 .AND. Y) THEN
		BB1 = .TRUE.
		GOTO 100
	ENDIF
\end{lstlisting}
由上面的分析，写出完全分支移除的算法如下：

\begin{algorithm}[H]
	\label{algo:CompleteBranchRemoval}
	\caption{$remove\_branches\left(x,cc_0\right)$}
	\KwIn{x是要考虑的分支，$cc_0$是x前的控制条件}
	\KwOut{返回x后面语句的控制条件$cc_1$，输出不含前向分支的版本}

	$cc_1\leftarrow cc_0$\;
	\While{$not\_empty\left(predicate\_list\left(x\right)\right)$}{
		$p\leftarrow get\_from\_queue\left(predicate\_list\left(x\right)\right)$\;
		$cc_1\leftarrow cc_1\vee p$\;
	}
	\Switch{$statement\_type(x)$}{
		\Case{前向分支IF(P) GOTO y}{
			创建一个新的分支标记$br_i$，其对应的FORTRAN变量为BRi\;
			把x替换为“IF($\mu\left(cc_1\right))$ BRi = P”\;
			$process\_branch\left(x,y,cc_1\wedge br_i\right)$\;
			$cc_1\leftarrow cc_1\wedge\neg br_1$\;
		}
		\Case{前向分支GOTO y}{
			$process\_branch\left(x,y,cc_1\right)$\;
			$cc_1\leftarrow false$\;
			删除分支x\;
		}
		\Case{后向分支IF(P) GOTO y}{
			创建一个新的分支标记$bb_j$，其对应的FORTRAN变量为BRj\;
			在y之前插入“BBj = .FALSE.”\;
			将x替换为代码段：
			
				“TPk = $\mu\left(cc_1\right)$”
				
				“IF(TPk) TPk = P”
				
				“IF(TPk) BBj = .TRUE.”
				
				“IF(TPK) GOTO y”\;
		}
		\Other{
			$guard\left(x\right)\leftarrow guard\left(x\right)\wedge cc_1$\;
		}
	}
	\Return{$cc_1$}
\end{algorithm}
其中的$process\_branch$如算法\ref{algo:ProcessBranch}所示:

\begin{algorithm}[H]
	\label{algo:ProcessBranch}
	\caption{$process\_branch\left(x,y,br\right)$}
	\KwIn{x是要考虑的分支,y是分支的目标，br是分支的条件}
	$stmt\_guard\leftarrow true$\;
	\For{x跳入的每个隐式循环区}{
		\tcc{设$bb_j$是控制这个隐式循环区的向后分支标记，$x_j$是相应后向分支的目标}
		$add\_to\_queue\left(predicate\_list\left(x_j\right),br\wedge bb_j\right)$\;
		$stmt\_guard\leftarrow stmt\_guard\wedge \neg bb_j$\;
	}
	$add\_to\_queue\left(predicate\_list\left(y\right),br\wedge stmt\_guard\right)$\;
\end{algorithm}

\subsection{布尔化简}

if转换会引入非常长的布尔表达式，如果这些表达式不进行化简，就会导致严重的效率低下。
（待完成）