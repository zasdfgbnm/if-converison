\subsection{RK算法}

CD函数并非是一个单值函数，不同的x可能对应相同的$CD\left(x\right)$。由于具有相同控制依赖的不同节点的执行条件相同，所以将节点转化为谓词执行以后，他们的谓词也应该相同，这样就可以为CD函数的值域中的每个元素分配一个与之一一对应的谓词p，谓词跟值域中元素的集合的对应关系记为K函数。显然，K函数是个单值函数，它的逆$K^{-1}$必然存在，记函数$R=CD\cdot K^{-1}$。可以看出，这么做将CD函数分解为R函数跟K函数：$CD=R\cdot K$。其中R函数负责将每个节点x与谓词p对应起来，而K则将每个谓词跟其对应的控制依赖对应起来。通过R函数，具有相同控制依赖（因而具有相同执行条件）的不同节点被映射到同一个谓词，也就是说，R函数为每个节点实现的谓词分配，节点x对应的谓词$p=R\left(x\right)$。至于K函数，则将每个谓词跟其控制依赖对应起来，这也为谓词的定义提供了参考。一种不错的谓词定义策略是，对于每一个谓词，在其对应的依赖，的相应节点末尾插入相应的赋值语句。例如$K\left(p\right)=\left\{y,-z\right\}$，则在y与z节点插入p的定义语句。插入的时候，如果对该点依赖值为正，则谓词的值就是分支条件，如果为赋，作为谓词的值就是该点分支条件的非。例如上面例子中，在y点插入$p=t_y$，而在z点插入$p=\neg t_z$。R函数以及K函数的计算算法如\fref{alg:ComputeRK}所示。

\begin{algorithm}[H]
	\label{alg:ComputeRK}
	\caption{ComputeRK}
	\KwIn{CD是控制依赖函数，N是G中节点的集合}
	\KwOut{R函数以及K函数}
	p = 1\tcc*{谓词命名从1开始顺序命名}
	\For{$x\in N$}{
		$t = CD\left(x\right)$\;
		\eIf{$t\in K$}{
			$R\left(x\right)=q$，其中q为使得$K\left(q\right)=t$的谓词\;
		}{
			$K\left(p\right)=t$\;
			$R\left(x\right)=p++$\;
		}
	}
\end{algorithm}
计算好R函数以及K函数，并按照R函数跟K函数进行谓词分配与定义以后，只要对控制流图进行拓扑排序即可得到转换后的代码。if-conversion的算法如\fref{alg:ifcvt}。

\begin{algorithm}[H]
	\label{alg:ifcvt}
	\caption{If-Conversion}
	\KwIn{G是控制流图，N是G中节点的集合，E是G中边的集合}
	\KwOut{转换后的代码}
	计算CD函数\;
	计算RK函数\;
	\For{$x\in N$}{
		$p=R\left(x\right)$\;
		\If{$K\left(p\right)\neq\varnothing$}{
			给x分配谓词$p$\;
		}
	}
	\For{每个谓词p}{
		\For{$\pm y\in K\left(p\right)$}{
			若是$+y$则在y尾部插入$p=t_y$\;
			若是$-y$则在y尾部插入$p=\neg t_y$;
		}
	}
	对G进行拓扑排序，删掉分支语句，并对已分配谓词的基本块进行谓词化\;
\end{algorithm}

使用RK算法进行if-conversion的示例如下：
如下控制流图，基本块的标签表示为$B_i\left(t_i\right)\&p_i$。图中$B_i$为基本块名称；$t_i$表示该基本块末尾会按照条件$t_i$分支，如果基本块不进行分支，则$\left(t_i\right)$不写；而$p_i$则表示谓词，如果基本块被无条件执行，则$p_i$也不写。

转换前的控制流图为：
\newcommand{\blockB}[1]{\parbox{5em}{\centering $B_{#1}$ \\ 代码段{#1};}}
\newcommand{\blockBT}[1]{\parbox{5em}{\centering $B_{#1}\left(t_{#1}\right)$ \\ 代码段{#1};}}
\begin{tikzpicture}[node distance = 2cm, auto]
	% Place nodes
	\node [cloud] (start) {Start};
	\node [block, below of=start] (B1) {\blockBT{1}};
	\node [block, below left of=B1, node distance=3cm] (B2) {\blockBT{2}};
	\node [block, below right of=B1, node distance=3cm] (B3) {\blockBT{3}};
	\node [block, below of=B2] (B4) {\blockB{4}};
	\node [block, below of=B3] (B5) {\blockB{5}};
	\node [block, below right of=B4, node distance=3cm] (B6) {\blockB{6}};
	\node [block, below of=B6] (B7) {\blockB{7}};
	\node [cloud, below of=B7, node distance=2cm] (stop) {Stop};
	% Draw edges
	\path [line] (start) -- (B1);
	\path [line] (B1) -- node [above] {T} (B2);
	\path [line] (B1) -- node {F} (B3);
	\path [line] (B2) -- node {T} (B4);
	\path [line] (B2) -- node {F} (B5);
	\path [line] (B3) -- node {T} (B5);
	\path [line] (B3) to[bend left=70] node {F} (B7);
	\path [line] (B4) -- (B6);
	\path [line] (B5) -- (B6);
	\path [line] (B6) -- (B7);
	\path [line] (B7) -- (stop);
\end{tikzpicture}
计算控制依赖得：\\
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
基本块 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\hline
$CD\left(x\right)$ & $\varnothing$ & $\left\{1\right\}$ & $\left\{-1\right\}$ & $\left\{2\right\}$ & $\left\{-2,3\right\}$ & $\left\{1,3\right\}$ & $\varnothing$ \\
\hline
\end{tabular}\\
将控制依赖分解为R函数跟K函数：\\
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
基本块 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\hline
$R\left(x\right)$ & $p_1$ & $p_2$ & $p_5$ & $p_4$ & $p_3$ & $p_6$ & $p_1$ \\
\hline
\end{tabular}\\
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
谓词 & $p_1$ & $p_2$ & $p_3$ & $p_4$ & $p_5$ & $p_6$ \\
\hline
$K\left(x\right)$ & $\varnothing$ & $\left\{1\right\}$ & $\left\{-2,3\right\}$ & $\left\{2\right\}$ & $\left\{-1\right\}$ & $\left\{1,3\right\}$\\
\hline
\end{tabular}\\
按照RK函数进行谓词分配与定义：
转换前的控制流图为：
\newcommand{\blockB}[1]{\parbox{5em}{\centering $B_{#1}$ \\ 代码段{#1};}}
\newcommand{\blockBT}[1]{\parbox{5em}{\centering $B_{#1}\left(t_{#1}\right)$ \\ 代码段{#1};}}
\begin{tikzpicture}[node distance = 2cm, auto]
	% Place nodes
	\node [cloud] (start) {Start};
	\node [block, below of=start] (B1) {\blockBT{1}};
	\node [block, below left of=B1, node distance=3cm] (B2) {\blockBT{2}};
	\node [block, below right of=B1, node distance=3cm] (B3) {\blockBT{3}};
	\node [block, below of=B2] (B4) {\blockB{4}};
	\node [block, below of=B3] (B5) {\blockB{5}};
	\node [block, below right of=B4, node distance=3cm] (B6) {\blockB{6}};
	\node [block, below of=B6] (B7) {\blockB{7}};
	\node [cloud, below of=B7, node distance=2cm] (stop) {Stop};
	% Draw edges
	\path [line] (start) -- (B1);
	\path [line] (B1) -- node [above] {T} (B2);
	\path [line] (B1) -- node {F} (B3);
	\path [line] (B2) -- node {T} (B4);
	\path [line] (B2) -- node {F} (B5);
	\path [line] (B3) -- node {T} (B5);
	\path [line] (B3) to[bend left=70] node {F} (B7);
	\path [line] (B4) -- (B6);
	\path [line] (B5) -- (B6);
	\path [line] (B6) -- (B7);
	\path [line] (B7) -- (stop);
\end{tikzpicture}